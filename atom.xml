<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gandalfliang的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gandalfliang.github.io/"/>
  <updated>2018-06-27T14:33:14.176Z</updated>
  <id>https://gandalfliang.github.io/</id>
  
  <author>
    <name>gandalfliang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 IDE 编译调试 Mlt framework</title>
    <link href="https://gandalfliang.github.io/2018/06/01/debugging-mlt/"/>
    <id>https://gandalfliang.github.io/2018/06/01/debugging-mlt/</id>
    <published>2018-06-01T17:32:41.000Z</published>
    <updated>2018-06-27T14:33:14.176Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.mltframework.org/" target="_blank" rel="noopener"><code>Mlt framework</code></a> 是一个开源跨平台的多媒体处理框架，使用模块化的设计，集成了大量的业界领先的视频处理框架，如ffmpeg，良好的设计，可以方便的集成自己的模块进去，利用它，你可以实现自己的 Adobe Premiere 等非线性多媒体编辑软件或者视频播放器，简单几句代码为视频添加炫酷的转场效果和滤镜。 </p><p>由于跨平台，项目通过configure的方式来管理工程，对于学习来说多媒体框架来说，调试起来并不方便，我整理了CMake的脚本，可以通过cmake来生成我们熟悉的 Visual Studio 或者 Xcode<br>工程，方便调试。  </p><p>在阅读下面文章之前，请确保你有一定的 MinGW 工具链使用经验。 </p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p><a href="https://github.com/gandalfliang/mlt" target="_blank" rel="noopener">https://github.com/gandalfliang/mlt</a><br>分支：cmake</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>对于 Windows 平台：  </p><ol><li>cmake</li><li>MinGW </li><li>msys2</li><li>Windows SDK  </li></ol><p>确保MinGW和msys2里的工具链路径在系统变量PATH中</p><p>Mac 平台：</p><ol><li>Xcode  </li></ol><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>在工程跟目录，运行脚本（如果是 Windows 平台，从开发者命令行工具运行）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py bootstrap.py</span><br></pre></td></tr></table></figure></p><p>如果一切顺利，工程文件将会在 <code>build/win32</code> 或者 <code>build/mac</code> 下。脚本运行要拉取ffmpeg的源码并configure，这是一个耗时的工作。在Windows平台下configure ffmpeg将是一个漫长的等待，没事的话，去喝杯咖啡，或者有空的时候在命令窗里敲一下enter键，可能会有收获哦。</p><p>完成后，你就可以愉快的调试这个框架了。 </p><img src="/2018/06/01/debugging-mlt/mac.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.mltframework.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Mlt framework&lt;/code&gt;&lt;/a&gt; 是一个开源跨平台的多媒体处理框架，使用模块化的设计，集成了大量的业界领
      
    
    </summary>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Mlt Framework" scheme="https://gandalfliang.github.io/tags/Mlt-Framework/"/>
    
      <category term="Xcode" scheme="https://gandalfliang.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Debug Mlt Framework in VSCode</title>
    <link href="https://gandalfliang.github.io/2018/04/17/debug_mlt_vscode/"/>
    <id>https://gandalfliang.github.io/2018/04/17/debug_mlt_vscode/</id>
    <published>2018-04-17T05:21:38.000Z</published>
    <updated>2018-04-17T02:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Debugging-Mlt-framework-in-VSCode"><a href="#Debugging-Mlt-framework-in-VSCode" class="headerlink" title="Debugging Mlt framework in VSCode"></a><code>Debugging Mlt framework in VSCode</code></h2><p><img src="http://omg3ewm0l.bkt.clouddn.com/mlt_vscode.png?imageView2/2/w/1920" alt="">  </p><p>Crossing platform with built in tool chain</p><p><img src="http://omg3ewm0l.bkt.clouddn.com/mlt_vscode_osx.png?imageView2/2/1920" alt="">  </p><p>Coming up soon (maybe)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Debugging-Mlt-framework-in-VSCode&quot;&gt;&lt;a href=&quot;#Debugging-Mlt-framework-in-VSCode&quot; class=&quot;headerlink&quot; title=&quot;Debugging Mlt framework in
      
    
    </summary>
    
      <category term="图片" scheme="https://gandalfliang.github.io/categories/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="VSCode" scheme="https://gandalfliang.github.io/tags/VSCode/"/>
    
      <category term="Mlt Framework" scheme="https://gandalfliang.github.io/tags/Mlt-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Gitsoler</title>
    <link href="https://gandalfliang.github.io/2018/03/21/Gitsoler1_1/"/>
    <id>https://gandalfliang.github.io/2018/03/21/Gitsoler1_1/</id>
    <published>2018-03-21T15:01:38.000Z</published>
    <updated>2018-03-21T15:22:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler"><a href="#Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler" class="headerlink" title="Gitsoler 1.1 - Split View supported: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler"></a>Gitsoler 1.1 - Split View supported: <a href="https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gitsoler-1-1-Split-View-supported-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler&quot;&gt;&lt;a href=&quot;#Gitsoler-1-1-Sp
      
    
    </summary>
    
      <category term="工具" scheme="https://gandalfliang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Extension" scheme="https://gandalfliang.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】关于 WPF 透明窗口的内存占用</title>
    <link href="https://gandalfliang.github.io/2018/02/16/transparent_4k_window.translate/"/>
    <id>https://gandalfliang.github.io/2018/02/16/transparent_4k_window.translate/</id>
    <published>2018-02-17T04:01:38.000Z</published>
    <updated>2018-05-21T09:05:39.592Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自己的文章才是最骚的。。。  <a href="https://gandalfliang.github.io/2018/01/17/transparent_4k_window/">Origin Post</a></p><hr><p>要实现一个透明的 WPF 窗口？<br>多么简单的一个任务啊！只要设置 AllowTransparency 和 WindowStyle，你可以在毫秒间完成这个任务。  </p><p><code>AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot;</code>   </p><p>正确吧？当然。<br>但是（你懂得），打开你的任务管理器看看，简单的任务通常会带来大量的内存占用，特别是4K分辨率的透明窗口。100+ MB的内存被浪费了，就只为了显示一个空白的透明窗口！这是不可接受的。一年前，如果你说：”谁关心内存呀，现在的内存条太便宜了”，你可能是对的。但是查查这一年内存条的价格走向，它们现在贵上天了。</p><h2 id="WPF-透明窗口的有趣小真相"><a href="#WPF-透明窗口的有趣小真相" class="headerlink" title="WPF 透明窗口的有趣小真相"></a>WPF 透明窗口的有趣小真相</h2><ul><li><code>内存占用随着窗口尺寸增大而增加</code></li><li><code>Win32 窗口没有这样的问题</code>  </li></ul><p>等等，什么？窗口越大，内存消耗的更多？嗯。。。这看起来很熟悉嘛，就像一个<code>Bitmap</code>。知道现在，我们并不知道 WPF 是如何处理透明窗口的，但是这种症状显示它就好像直接将整个桌面作为一个位图，然后窗口用这张位图的重叠部分作为其背景来更新自己，让它看起来是“透明”的。多么聪明的做法呀。。。<br>在 WPF 刚刚发布的那些日子里，低分辨率的计算机屏幕占据主流位置，即使在今天，大多数的笔记本电脑依然带着一块1366*768分辨率的屏幕被推向市场（离谱吧）。让我们唾弃那些OEM厂商讲的毫无根据的废话并且思考一下运行在高分辨率下的程序的情况。  </p><h2 id="内存并不是免费的，不要浪费之"><a href="#内存并不是免费的，不要浪费之" class="headerlink" title="内存并不是免费的，不要浪费之"></a>内存并不是免费的，不要浪费之</h2><p>很显然，浪费100+MB的内存来显示一个4K的透明窗口是不可接受的，特别是和 Win32 窗口只占用10+MB的内存进行比较时。这差距让 WPF 看起来蠢透了。<br>抱怨已经够多了，想想对此我们能做什么呢？我可不想用C++和GDI将我的UI代码重写一遍，这太没效率并且也跟不上时代，况且，没人会为此“区区小事”去放弃他们漂亮、易于维护的Xaml UI代码。  </p><h2 id="使用-Win32-承载-WPF-内容"><a href="#使用-Win32-承载-WPF-内容" class="headerlink" title="使用 Win32 承载 WPF 内容"></a>使用 Win32 承载 WPF 内容</h2><p>好吧，确实，没人愿意为了区区90MB内存去重写它们的UI。与使用C++重写UI所耗费的精力相比，这个内存的占用差距看起来是可以接受的（#笑脸）。但是请记住，我们一如既往的可以在 Win32 窗口中承载 WPF 的内容。<br>例如，我们想创建一个全屏、半透明背景带着非透明内容的对话框。为了规避 WPF 透明窗口的内存问题，我们可以使用 Win32 创建一个半透明的窗口：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DWORD Flags1 = WS_EX_LAYERED;</span><br><span class="line">DWORD Flags2 = WS_POPUP;</span><br><span class="line"></span><br><span class="line">HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, <span class="number">3840</span>,<span class="number">2160</span>, nullptr, nullptr, hInstance, nullptr);</span><br><span class="line"></span><br><span class="line">SetLayeredWindowAttributes(hWnd, RRR, (BYTE)<span class="number">125</span>, LWA_ALPHA);</span><br><span class="line">ShowWindow(hWnd, nCmdShow);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_ERASEBKGND:</span><br><span class="line">    RECT rect;</span><br><span class="line">    GetClientRect(hWnd, &amp;rect);</span><br><span class="line">    FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>通过启用 <code>C++/CLI</code>，我们可以直接访问 WPF 内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace ManagedCode</span><br><span class="line">&#123;</span><br><span class="line">    using namespace System;</span><br><span class="line">    using namespace System::Windows;</span><br><span class="line">    using namespace System::Windows::Interop;</span><br><span class="line">    using namespace System::Windows::Media;</span><br><span class="line"></span><br><span class="line">    HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123;</span><br><span class="line">    HwndSource^ source = gcnew HwndSource(</span><br><span class="line">        <span class="number">0</span>, <span class="comment">// class style  </span></span><br><span class="line">        WS_VISIBLE | WS_CHILD, <span class="comment">// style  </span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// exstyle  </span></span><br><span class="line">        x, y, width, height,</span><br><span class="line">        <span class="string">"hi"</span>, <span class="comment">// NAME  </span></span><br><span class="line">        IntPtr(parent)        <span class="comment">// parent window   </span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    UIElement^ page = gcnew ManagedContent::WPFContent();</span><br><span class="line">    source-&gt;RootVisual = page;</span><br><span class="line">    <span class="keyword">return</span> (HWND)source-&gt;Handle.ToPointer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//managed content</span></span><br><span class="line">ManagedCode::GetHwnd(hWnd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>由于 WPF 和 GDI 背后的技术不尽相同，还有更多的工作需要做来解决不可避免的透明通道问题，但是，为了方便，你始终可以使用 Popup 来实现你的目标。</p><hr><p>Macbook Pro 2016 的键盘真垃圾。。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻译自己的文章才是最骚的。。。  &lt;a href=&quot;https://gandalfliang.github.io/2018/01/17/transparent_4k_window/&quot;&gt;Origin Post&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要实现一个透明的 WPF 窗口？&lt;
      
    
    </summary>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="LayeredWindow" scheme="https://gandalfliang.github.io/tags/LayeredWindow/"/>
    
      <category term="Performance" scheme="https://gandalfliang.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>Light Weighted DropshadowEffect</title>
    <link href="https://gandalfliang.github.io/2018/02/12/lightweighted_shadoweffect/"/>
    <id>https://gandalfliang.github.io/2018/02/12/lightweighted_shadoweffect/</id>
    <published>2018-02-12T18:58:27.000Z</published>
    <updated>2018-05-21T09:05:39.592Z</updated>
    
    <content type="html"><![CDATA[<p>Let’s create a light weighted wpf drop shadow effect, considering that the origin one performs badly in some special occasions.<br>As I mentioned before (<a href="https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/">check it out</a>), the original WPF DropShadow Effect can cause severe preformance problem. Due to the “flaw” M$FT brought to the HLSL support for WPF, the Effect class that implements the visual effect creates and destroy GPU resource each frame, which is the worst thing you could do with GPU resources. So, what about implementing a custom shadow effect to avoid it? This sounds interesting.  </p><p>– 春节补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Let’s create a light weighted wpf drop shadow effect, considering that the origin one performs badly in some special occasions.&lt;br&gt;As I m
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="高性能计算" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="图像处理" scheme="https://gandalfliang.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于 WPF 透明窗口的内存占用</title>
    <link href="https://gandalfliang.github.io/2018/01/17/transparent_4k_window/"/>
    <id>https://gandalfliang.github.io/2018/01/17/transparent_4k_window/</id>
    <published>2018-01-17T16:01:38.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>要实现一个透明的 WPF 窗口？<br>What an easy task! By setting AllowTransparency and WindowStyle, you could finish it in seconds.   </p><p><code>AllowTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; Background=&quot;Transparent&quot;</code>   </p><p>Correct? Of course.  </p><p>However (you know this is coming), look at your task manager, easy task comes with large memory consumption, especially for 4K transparent window. 100+ MB ram are wasted for just showing an empty, transparent window! That’s unacceptable. A year ago, you might be right saying “Who cares about RAM, they are cheap as hell”, but check out the price they’ve grown over this year, they are expensive as hell now.  </p><h2 id="Fun-fact-of-WPF-transparent-window"><a href="#Fun-fact-of-WPF-transparent-window" class="headerlink" title="Fun fact of WPF transparent window"></a>Fun fact of WPF transparent window</h2><ul><li><code>RAM usage increase as window size enlarge</code>  </li><li><code>Win32 window has no such problem</code>  </li></ul><p>Wait, what? The larger the window is, the more RAM it consumes? Hmmmmm… this looks familiar, just like a <code>Bitmap</code>. For now, we don’t know how WPF handles transparent window, but the symptom shows that it’s like using the whole screen as a bitmap and the window updating itself with portion of that bitmap, making it “transparent”. What a smart move…<br>Back in the days when WPF was first released, low screen resolution was the main stream. Even today, most laptops still are shipping with a monitor of 1366*768 (ridiculous, right?). Let’s despise the nonsense the OEM told us and think about program running in computers with higher screen resolution. </p><h2 id="RAM-is-not-free-do-not-waste-it"><a href="#RAM-is-not-free-do-not-waste-it" class="headerlink" title="RAM is not free, do not waste it"></a>RAM is not free, do not waste it</h2><p>Obviously, costing 100+ mb of ram for showing a transparent window in 4K is unacceptable, especially compared with Win32 transparent window, which costs only 10+ mb. The gap between them makes WPF look dump.<br>Enough complaining, what can we do about it? I don’t want to write UI code with GDI using C++, that’s inefficient and not modern, plus, no one would abandon their beautiful, easy to maintain xaml UI code for this.</p><h2 id="Hosting-WPF-content-in-Win32-Window"><a href="#Hosting-WPF-content-in-Win32-Window" class="headerlink" title="Hosting WPF content in Win32 Window"></a>Hosting WPF content in Win32 Window</h2><p>Well, indeed, no one would rewrite their UI code for just about 90mb of RAM. Compared with the work needed to rewrite C++ UI code, the RAM consumption gap seems acceptable (#smile face). But please remember, we can always host WPF content in win32 window.<br>Let say, we want to create a full screen notification dialog with semi-transparent background and apaque notication content in the center. To avoid the WPF ram problem, we create a semi-transparent window using win32:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DWORD Flags1 = WS_EX_LAYERED;</span><br><span class="line">DWORD Flags2 = WS_POPUP;</span><br><span class="line"></span><br><span class="line">HWND hWnd = CreateWindowEx(Flags1,szWindowClass, szTitle, Flags2,</span><br><span class="line">    CW_USEDEFAULT, <span class="number">0</span>, <span class="number">3840</span>,<span class="number">2160</span>, nullptr, nullptr, hInstance, nullptr);</span><br><span class="line"></span><br><span class="line">SetLayeredWindowAttributes(hWnd, RRR, (BYTE)<span class="number">125</span>, LWA_ALPHA);</span><br><span class="line">ShowWindow(hWnd, nCmdShow);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_ERASEBKGND:</span><br><span class="line">    RECT rect;</span><br><span class="line">    GetClientRect(hWnd, &amp;rect);</span><br><span class="line">    FillRect((HDC)wParam, &amp;rect, CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>By enabling <code>C++/CLI</code>, we can access WPF content directly  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace ManagedCode</span><br><span class="line">&#123;</span><br><span class="line">    using namespace System;</span><br><span class="line">    using namespace System::Windows;</span><br><span class="line">    using namespace System::Windows::Interop;</span><br><span class="line">    using namespace System::Windows::Media;</span><br><span class="line"></span><br><span class="line">    HWND GetHwnd(HWND parent, int x, int y, int width, int height) &#123;</span><br><span class="line">    HwndSource^ source = gcnew HwndSource(</span><br><span class="line">        <span class="number">0</span>, <span class="comment">// class style  </span></span><br><span class="line">        WS_VISIBLE | WS_CHILD, <span class="comment">// style  </span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// exstyle  </span></span><br><span class="line">        x, y, width, height,</span><br><span class="line">        <span class="string">"hi"</span>, <span class="comment">// NAME  </span></span><br><span class="line">        IntPtr(parent)        <span class="comment">// parent window   </span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    UIElement^ page = gcnew ManagedContent::WPFContent();</span><br><span class="line">    source-&gt;RootVisual = page;</span><br><span class="line">    <span class="keyword">return</span> (HWND)source-&gt;Handle.ToPointer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and finally  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//managed content</span></span><br><span class="line">ManagedCode::GetHwnd(hWnd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>Due to the different technologies behind WPF and GDI, more work needed to be done for the unavoidable alpha blending problem, but, you can use wpf popup to achieve your goal for short. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要实现一个透明的 WPF 窗口？&lt;br&gt;What an easy task! By setting AllowTransparency and WindowStyle, you could finish it in seconds.   &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Allo
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="LayeredWindow" scheme="https://gandalfliang.github.io/tags/LayeredWindow/"/>
    
      <category term="Performance" scheme="https://gandalfliang.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCL 实现图片高斯模糊</title>
    <link href="https://gandalfliang.github.io/2018/01/02/gaussian_blur_opencl/"/>
    <id>https://gandalfliang.github.io/2018/01/02/gaussian_blur_opencl/</id>
    <published>2018-01-02T18:58:27.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>高斯模糊（ <a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A</a> ）是一种常见的图像处理算法，使用高斯分布与图像做卷积，得到模糊的效果。其二维定义：<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c36071d89adc2f4da470b45ce05c33ca93744577" alt=""> </p><p>σ是正态分布的标准偏差。在应用的时候，假设σ为2.5。对于模糊半径为1，则高斯矩阵为3*3的一个矩阵，以[1,1]为中心，带入公式计算高斯矩阵的值，得到：  </p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0.0216996633</td><td>0.0235069655</td><td>0.0216996633  </td></tr><tr><td>0.0235069655</td><td>0.0254647918</td><td>0.0235069655  </td></tr><tr><td>0.0216996633</td><td>0.0235069655</td><td>0.0216996633  </td></tr></tbody></table><p>他们的和为 0.206291318，我们需要他们的和为1，因此与总和相除得到：  </p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0.105189413</td><td>0.113950342</td><td>0.105189413  </td></tr><tr><td>0.113950342</td><td>0.123440929</td><td>0.113950342  </td></tr><tr><td>0.105189413</td><td>0.113950342</td><td>0.105189413  </td></tr></tbody></table><p>根据这个矩阵，对图像的每个像素点进行计算，计算的九个点的各rgb分量之和就是最终像素的rgb分量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算高斯矩阵</span></span><br><span class="line">private <span class="keyword">void</span> ComputeWeightMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> center = Radius;</span><br><span class="line">    <span class="keyword">var</span> conBase = <span class="number">2</span> * <span class="built_in">Math</span>.Pow(Variance, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> conRoot = <span class="number">1</span> / (<span class="built_in">Math</span>.PI * conBase);</span><br><span class="line"></span><br><span class="line">    float sum = <span class="number">0</span>f;</span><br><span class="line">    <span class="keyword">for</span> (int x = -Radius; x &lt;= Radius; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int y = Radius; y &gt;= -Radius; y--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> weight = conRoot * <span class="built_in">Math</span>.Pow(<span class="built_in">Math</span>.E, -(x * x + y * y) / conBase);</span><br><span class="line">            _matrix[GridPosToArrayIndex(x, y, center, Radius)] = (float)weight;</span><br><span class="line">            sum += (float)weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; _matrix.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _matrix[i] /= sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Compute</span></span><br><span class="line">public <span class="keyword">void</span> Compute(string imageFile)</span><br><span class="line">&#123;</span><br><span class="line">    using (<span class="keyword">var</span> bitmap = <span class="keyword">new</span> Bitmap(imageFile))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> datas = bitmap.LockBits(<span class="keyword">new</span> Rectangle(<span class="keyword">new</span> Point(), <span class="keyword">new</span> Size(bitmap.Width, bitmap.Height)),ImageLockMode.ReadOnly,bitmap.PixelFormat);</span><br><span class="line">        <span class="keyword">var</span> dataSize = datas.Stride * datas.Height;</span><br><span class="line">        <span class="keyword">var</span> argbs = <span class="keyword">new</span> byte[dataSize];</span><br><span class="line">        <span class="keyword">var</span> dsts = <span class="keyword">new</span> byte[dataSize];</span><br><span class="line">        int matrixWidth = Radius * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        Marshal.Copy(datas.Scan0, argbs, <span class="number">0</span>, dataSize);</span><br><span class="line"></span><br><span class="line">        Stopwatch sw=Stopwatch.StartNew();</span><br><span class="line">        <span class="keyword">for</span> (int y = <span class="number">0</span>; y &lt; bitmap.Height; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt; bitmap.Width; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                float sumA = <span class="number">0</span>;</span><br><span class="line">                float sumR = <span class="number">0</span>;</span><br><span class="line">                float sumG = <span class="number">0</span>;</span><br><span class="line">                float sumB=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; _matrix.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> pos = transform_pos(x, y, matrixWidth, bitmap.Width, bitmap.Height, Radius, i);</span><br><span class="line">                    <span class="keyword">var</span> position = pos.Y * datas.Stride + pos.X*<span class="number">4</span>;</span><br><span class="line">                    sumR += argbs[position] * _matrix[i];</span><br><span class="line">                    sumG += argbs[position + <span class="number">1</span>] * _matrix[i];</span><br><span class="line">                    sumB += argbs[position + <span class="number">2</span>] * _matrix[i];</span><br><span class="line">                    sumA += argbs[position + <span class="number">3</span>] * _matrix[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> dstPos = y * datas.Stride + x * <span class="number">4</span>;</span><br><span class="line">                dsts[dstPos] = (byte)sumR;</span><br><span class="line">                dsts[dstPos+<span class="number">1</span>] = (byte)sumG;</span><br><span class="line">                dsts[dstPos+<span class="number">2</span>] = (byte)sumB;</span><br><span class="line">                dsts[dstPos+<span class="number">3</span>] = (byte)sumA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap.UnlockBits(datas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> elapse = sw.Elapsed;</span><br><span class="line">        Console.WriteLine($<span class="string">"Costing: &#123;elapse&#125;"</span>);</span><br><span class="line">        Debug.WriteLine($<span class="string">"Costing: &#123;elapse&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> handle = GCHandle.Alloc(dsts, GCHandleType.Pinned);</span><br><span class="line">        using (<span class="keyword">var</span> dstBmp = <span class="keyword">new</span> Bitmap(datas.Width, datas.Height, datas.Stride, bitmap.PixelFormat,</span><br><span class="line">            handle.AddrOfPinnedObject()))</span><br><span class="line">        &#123;</span><br><span class="line">            dstBmp.Save(<span class="string">"processed_normal.bmp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handle.Free();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，这样能完成工作，但是耗时太长，对于3000*1920尺寸的图片处理需要2分51秒（Intel Core i7-4770)，这显然是不可接受的。<br>对于这种分别计算每个像素，且各像素间互不干扰的问题，使用OpenCL可以大幅降低时间消耗。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenCL 高斯模糊代码</span></span><br><span class="line"><span class="comment">    Copyright Gandalfliang</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">inline int2 transform_pos(int centerX,int centerY,int matrixWidth,int radius,int index)</span><br><span class="line">&#123;</span><br><span class="line">    int x=index%matrixWidth;</span><br><span class="line">    int offsetX=x-(radius+<span class="number">1</span>);</span><br><span class="line">    int y=index/matrixWidth;</span><br><span class="line">    int offsetY=radius-y;</span><br><span class="line">    <span class="keyword">return</span> (int2)(centerX+offsetX,centerY-offsetY);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sampler_t sampler_img=CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP_TO_EDGE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//opencl kernel 代码</span></span><br><span class="line">kernel <span class="keyword">void</span> gaussian_blur(</span><br><span class="line">    read_only image2d_t src,</span><br><span class="line">    global write_only char* dst,</span><br><span class="line">    global read_only float* matrix,</span><br><span class="line">    read_only int radius,</span><br><span class="line">read_only int width)</span><br><span class="line">&#123;</span><br><span class="line">    int x=get_global_id(<span class="number">0</span>);</span><br><span class="line">    int y=get_global_id(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    float sumR,sumG,sumB,sumA;</span><br><span class="line">    int matrixWidth=radius*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    int matrix_size=pow(matrixWidth,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;matrix_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int2 pix=transform_pos(x,y,matrixWidth,radius,i);</span><br><span class="line">        uint4 rgba = read_imageui(src,sampler_img,pix);</span><br><span class="line">        sumR+=rgba.x*matrix[i];</span><br><span class="line">        sumG+=rgba.y*matrix[i];</span><br><span class="line">        sumB+=rgba.z*matrix[i];</span><br><span class="line">sumA+=rgba.w*matrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">int loc=y*width*<span class="number">4</span>+x*<span class="number">4</span>;</span><br><span class="line">dst[loc]=sumR;</span><br><span class="line">dst[loc+<span class="number">1</span>]=sumG;</span><br><span class="line">dst[loc+<span class="number">2</span>]=sumB;</span><br><span class="line">dst[loc+<span class="number">3</span>]=sumA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Host代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> Compute_cl(string imageFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//选取设备</span></span><br><span class="line">    <span class="keyword">var</span> platform = ComputePlatform.Platforms.FirstOrDefault();</span><br><span class="line">    <span class="keyword">var</span> device = platform.Devices.FirstOrDefault();</span><br><span class="line">    <span class="comment">//设置相关上下文</span></span><br><span class="line">    <span class="keyword">var</span> properties = <span class="keyword">new</span> ComputeContextPropertyList(platform);</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> ComputeContext(<span class="keyword">new</span>[] &#123;device&#125;, properties, <span class="literal">null</span>, IntPtr.Zero);</span><br><span class="line">    <span class="comment">//命令队列，用于控制执行的代码</span></span><br><span class="line">    ComputeCommandQueue commands = <span class="keyword">new</span> ComputeCommandQueue(context, context.Devices[<span class="number">0</span>],</span><br><span class="line">        ComputeCommandQueueFlags.None);</span><br><span class="line">    <span class="comment">//读取opencl代码</span></span><br><span class="line">    <span class="keyword">var</span> code = File.ReadAllText(@<span class="string">"gaussianblur.cl"</span>);</span><br><span class="line">    <span class="comment">//编译</span></span><br><span class="line">    <span class="keyword">var</span> program = <span class="keyword">new</span> ComputeProgram(context, code);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        program.Build(<span class="keyword">new</span>[] &#123;device&#125;, <span class="literal">null</span>, <span class="literal">null</span>, IntPtr.Zero);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> images = CreateImageFromBitmap(imageFile, context,</span><br><span class="line">        ComputeMemoryFlags.ReadWrite | ComputeMemoryFlags.CopyHostPointer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建核心代码，就是cl代码中以kernel标识的函数</span></span><br><span class="line">    <span class="keyword">var</span> kernel = program.CreateKernel(<span class="string">"gaussian_blur"</span>);</span><br><span class="line">    <span class="comment">//矩阵规模</span></span><br><span class="line">    <span class="comment">//储存计算结果的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建的核心代码函数以这种方式来传参</span></span><br><span class="line">    <span class="keyword">var</span> resultBuffer=<span class="keyword">new</span> ComputeBuffer&lt;char&gt;(context,ComputeMemoryFlags.WriteOnly, dstBytes.Length);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="number">0</span>, images);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="number">1</span>, resultBuffer);</span><br><span class="line">    kernel.SetMemoryArgument(<span class="number">2</span>, <span class="keyword">new</span> ComputeBuffer&lt;float&gt;(context,ComputeMemoryFlags.ReadOnly|ComputeMemoryFlags.CopyHostPointer,_matrix));</span><br><span class="line">    kernel.SetValueArgument(<span class="number">3</span>, Radius);</span><br><span class="line">    kernel.SetValueArgument(<span class="number">4</span>, (int)images.Width);</span><br><span class="line">    Console.WriteLine($<span class="string">"运行平台: &#123;platform.Name&#125;\n运行设备： &#123;device.Name&#125;\n"</span>);</span><br><span class="line">    Stopwatch sw = Stopwatch.StartNew();</span><br><span class="line">    <span class="keyword">var</span> climg = images;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行代码</span></span><br><span class="line">    commands.Execute(kernel, <span class="literal">null</span>, <span class="keyword">new</span> long[] &#123;climg.Width, climg.Height&#125;, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//read data</span></span><br><span class="line">    char[] resultArray = <span class="keyword">new</span> char[dstBytes.Length];</span><br><span class="line">    <span class="keyword">var</span> arrHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned);</span><br><span class="line">    commands.Read(resultBuffer, <span class="literal">true</span>, <span class="number">0</span>, dstBytes.Length, arrHandle.AddrOfPinnedObject(), <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//commands.ReadFromImage(images.Item2, processeddata.Scan0, true, null);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resultHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned);</span><br><span class="line">    <span class="keyword">var</span> bmp=<span class="keyword">new</span> Bitmap(climg.Width,climg.Height, climg.Width*<span class="number">4</span>, PixelFormat.Format32bppArgb, resultHandle.AddrOfPinnedObject());</span><br><span class="line">    <span class="keyword">var</span> elapsed = sw.Elapsed;</span><br><span class="line">    Console.WriteLine($<span class="string">"耗时: &#123;elapsed.TotalMilliseconds&#125; ms\n"</span>);</span><br><span class="line">    kernel.Dispose();</span><br><span class="line"></span><br><span class="line">    bmp.Save(<span class="string">"processed_cl.bmp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相同尺寸的图片处理，使用 Intel Core i7-4770 自带的核显 HD4600 处理，耗时只需要164毫秒。</p><p>以下是相关测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：790*501</span><br><span class="line">OpenCL处理耗时: 13.6597 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：790*501</span><br><span class="line">常规方法耗时: 11482.9402 ms</span><br><span class="line"></span><br><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：1339*693</span><br><span class="line">OpenCL处理耗时: 33.0095 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：1339*693</span><br><span class="line">常规方法耗时: 26908.9926 ms</span><br><span class="line"></span><br><span class="line">运行平台: Intel(R) OpenCL</span><br><span class="line">运行设备： Intel(R) HD Graphics 4600</span><br><span class="line">处理图片尺寸：1920*1080</span><br><span class="line">OpenCL处理耗时: 51.3885 ms</span><br><span class="line"></span><br><span class="line">处理图片尺寸：1920*1080</span><br><span class="line">常规方法耗时: 60147.3815 ms</span><br></pre></td></tr></table></figure></p><p>当然，常规方法都只使用了单线程，还未发挥多核CPU的威力，然而，可以预见的是，即使是使用多线程，提升也是有限的。</p><p>原图：<br><img src="http://omg3ewm0l.bkt.clouddn.com/screen_shot_gaus.png" alt=""><br>高斯模糊：<br><img src="http://omg3ewm0l.bkt.clouddn.com/processed_cl.bmp" alt=""></p><p>代码： <a href="https://github.com/gandalfliang/cloo_netstandard/tree/temp" target="_blank" rel="noopener">https://github.com/gandalfliang/cloo_netstandard/tree/temp</a> </p><font size="4" color="red">Update: 在nVidia的环境下会导致处理后的图片出现花屏现象，估计是cl代码的问题，又或者是nVidia的驱动有问题？下次再更新</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高斯模糊（ &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.or
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="高性能计算" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
      <category term="高斯模糊" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/"/>
    
      <category term="图像处理" scheme="https://gandalfliang.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>.NET Standard CLOO</title>
    <link href="https://gandalfliang.github.io/2017/12/25/cloo_net_standard/"/>
    <id>https://gandalfliang.github.io/2017/12/25/cloo_net_standard/</id>
    <published>2017-12-25T16:01:38.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于 .NET Standard 2.0 已经支持大量的.NET api，移植CLOO已经是毫无难度的一件事情 <a href="https://github.com/gandalfliang/cloo_netstandard" target="_blank" rel="noopener">Github</a></p><p>CLOO使用p/invoke方式调用opencl api，但是对于不同平台下，opencl 的名称并不一致，例如在linux下为libOpenCL.so，Windows下为OpenCL.dll，且 .NET Standard 没有提供 Mono 类似的 dllmap 模式，因此，现在来说还不能达到用一个package，在所有平台引用的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;鉴于 .NET Standard 2.0 已经支持大量的.NET api，移植CLOO已经是毫无难度的一件事情 &lt;a href=&quot;https://github.com/gandalfliang/cloo_netstandard&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CLOO" scheme="https://gandalfliang.github.io/tags/CLOO/"/>
    
      <category term="NET Standard" scheme="https://gandalfliang.github.io/tags/NET-Standard/"/>
    
  </entry>
  
  <entry>
    <title>Gitsoler</title>
    <link href="https://gandalfliang.github.io/2017/12/16/Gitsoler/"/>
    <id>https://gandalfliang.github.io/2017/12/16/Gitsoler/</id>
    <published>2017-12-16T16:01:38.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler"><a href="#Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler" class="headerlink" title="Gitsoler - a Visual Studio extension, now goes public: https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler"></a>Gitsoler - a Visual Studio extension, now goes public: <a href="https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=gandalfliang.gitsoler</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gitsoler-a-Visual-Studio-extension-now-goes-public-https-marketplace-visualstudio-com-items-itemName-gandalfliang-gitsoler&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="工具" scheme="https://gandalfliang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Visual Studio" scheme="https://gandalfliang.github.io/tags/Visual-Studio/"/>
    
      <category term="Extension" scheme="https://gandalfliang.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>“阻断疗法” - 拯救 WPF 启动过程中发生设备热插拔导致触摸失效问题</title>
    <link href="https://gandalfliang.github.io/2017/12/02/WPFLostTouchCapability/"/>
    <id>https://gandalfliang.github.io/2017/12/02/WPFLostTouchCapability/</id>
    <published>2017-12-02T18:58:27.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omg3ewm0l.bkt.clouddn.com/windows-10-bsods-on-asus-pcs-faulty-hardware-corrupted-page-error-492252-2.jpg" alt=""><br>如果你在WPF程序启动过程中进行设备热插拔（例如，插入一个U盘，一个USB摄像头），那么你的WPF程序很有可能失去所有触摸消息响应，通过 Tablet.TabletDevices.Count 检查当前程序的挂靠触摸设备，发现为0。有趣的是，如果你将触摸线重新插拔后，程序恢复正常。所以，这是WPF的Bug，微软的锅。那么这个锅的根本原因是啥？有兴趣的可以调试 .net framework 源码，这里没有深究。<br>如上面讲到，触摸线重新插拔就可以解决这个问题，但是，导致这个问题的热插拔设备也不是触摸设备啊，只是一个普通的U盘，反过来想，如果导致问题的不是触摸设备热插拔，反而触摸设备的热插拔能够修复这个问题，那我能不能“模拟”一下触摸设备的热插拔事件呢？在这篇<a href="https://msdn.microsoft.com/en-us/library/dd901337%28v=vs.90%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">文章</a>里描述怎样模拟触摸设备移除事件来达到禁用WPF触摸的效果,反过来试试，通过 OnTabletAdded 事件看看能不能发生奇迹。然而，奇迹并没有发生，所以这个方法不行。<br>既然模拟设备添加事件的方法不行，那我从源头阻挡这个问题的发生：启动过程中不要处理设备变动事件。那么问题来了，我想要阻断 win32 WM 事件通知，必须要拿到一个窗口句柄呀，但是在 mainwindow show 出来的时候，这个问题已经发生了，这个时候的阻断已经没有效果了，一定要程序启动一开始做阻断。进一步搜索，这里<a href="https://stackoverflow.com/questions/38642479/how-to-disable-wpf-tablet-support-in-surface-4-pro" target="_blank" rel="noopener">https://stackoverflow.com/questions/38642479/how-to-disable-wpf-tablet-support-in-surface-4-pro</a> 是一个突破口：  </p><blockquote><p>WPF does not register to these messages on the applications MainWindow, but through a hidden windows named “SystemResources…” which is created for each application instance. So handling those messages on the MainWindow (which would be easy) does not help here.</p></blockquote><p>相信看到这里，聪明的你已经知道怎么做了。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WPFTouchUtil</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">//添加钩子，阻断设备改动消息</span></span><br><span class="line">        public <span class="keyword">static</span> <span class="keyword">void</span> HandleDeviceChangedWM()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hook into internal class SystemResources to keep it from updating the TabletDevices on system events</span></span><br><span class="line">            object hwndWrapper = GetSystemResourcesHwnd();</span><br><span class="line">            <span class="keyword">if</span> (hwndWrapper != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// invoke hwndWrapper.AddHook( .. our method ..)</span></span><br><span class="line">                <span class="keyword">var</span> internalHwndWrapperType = hwndWrapper.GetType();</span><br><span class="line">                <span class="comment">// if the delegate is already set, we have already added the hook.</span></span><br><span class="line">                <span class="keyword">if</span> (_handleAndHideMessageDelegate == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// create the internal delegate that will hook into the window messages</span></span><br><span class="line">                    <span class="comment">// need to hold a reference to that one, because internally the delegate is stored through a WeakReference object</span></span><br><span class="line">                    <span class="keyword">var</span> internalHwndWrapperHookDelegate = internalHwndWrapperType.Assembly.GetType(<span class="string">"MS.Win32.HwndWrapperHook"</span>);</span><br><span class="line">                    <span class="keyword">var</span> handleAndHideMessagesHandle = <span class="keyword">typeof</span>(WPFTouchUtil).GetMethod(nameof(HandleAndHideMessages), BindingFlags.Static | BindingFlags.NonPublic);</span><br><span class="line">                    _handleAndHideMessageDelegate = Delegate.CreateDelegate(internalHwndWrapperHookDelegate, handleAndHideMessagesHandle);</span><br><span class="line">                    <span class="comment">// add a delegate that handles WM_TABLET_ADD</span></span><br><span class="line">                    internalHwndWrapperType.InvokeMember(<span class="string">"AddHook"</span>,</span><br><span class="line">                        BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public,</span><br><span class="line">                        <span class="literal">null</span>, hwndWrapper, <span class="keyword">new</span> object[] &#123; _handleAndHideMessageDelegate &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除钩子，恢复状态</span></span><br><span class="line">        public <span class="keyword">static</span> <span class="keyword">void</span> RestoreDeviceChangedWM()</span><br><span class="line">        &#123;</span><br><span class="line">            object hwndWrapper = GetSystemResourcesHwnd();</span><br><span class="line">            <span class="keyword">if</span> (hwndWrapper != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> internalHwndWrapperType = hwndWrapper.GetType();</span><br><span class="line"></span><br><span class="line">                internalHwndWrapperType.InvokeMember(<span class="string">"RemoveHook"</span>,</span><br><span class="line">                    BindingFlags.InvokeMethod | BindingFlags.Instance | BindingFlags.Public,</span><br><span class="line">                    <span class="literal">null</span>, hwndWrapper, <span class="keyword">new</span> object[] &#123;_handleAndHideMessageDelegate&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private <span class="keyword">static</span> Delegate _handleAndHideMessageDelegate = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        private <span class="keyword">static</span> object GetSystemResourcesHwnd()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> internalSystemResourcesType = <span class="keyword">typeof</span>(Application).Assembly.GetType(<span class="string">"System.Windows.SystemResources"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get HwndWrapper from internal property SystemRessources.Hwnd;</span></span><br><span class="line">            <span class="keyword">var</span> hwndWrapper = internalSystemResourcesType.InvokeMember(<span class="string">"Hwnd"</span>,</span><br><span class="line">                        BindingFlags.GetProperty | BindingFlags.Static | BindingFlags.NonPublic,</span><br><span class="line">                        <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> hwndWrapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private <span class="keyword">static</span> IntPtr HandleAndHideMessages(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg == (int)WindowMessage.WM_DEVICECHANGE)</span><br><span class="line">            &#123;</span><br><span class="line">                handled = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> IntPtr.Zero;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        enum WindowMessage : int</span><br><span class="line">        &#123;</span><br><span class="line">            WM_DEVICECHANGE = <span class="number">0x0219</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在程序刚启动的时候添加“阻断”，启动流程过后，不要忘了恢复状态。<br>缺陷，如果程序启动过程中，真的发生了触摸设备变动，也会被阻断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://omg3ewm0l.bkt.clouddn.com/windows-10-bsods-on-asus-pcs-faulty-hardware-corrupted-page-error-492252-2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果你
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="BUG" scheme="https://gandalfliang.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>Timelapse#2</title>
    <link href="https://gandalfliang.github.io/2017/10/20/Timelapse2/"/>
    <id>https://gandalfliang.github.io/2017/10/20/Timelapse2/</id>
    <published>2017-10-21T00:33:39.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lens: Nikkor 24-70mm F2.8<br>f2.8  70mm  ISO400 </p><video src="http://omg3ewm0l.bkt.clouddn.com/gz_timelapse_cold_signature.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lens: Nikkor 24-70mm F2.8&lt;br&gt;f2.8  70mm  ISO400 &lt;/p&gt;
&lt;video src=&quot;http://omg3ewm0l.bkt.clouddn.com/gz_timelapse_cold_signature.mp4&quot; type=&quot;
      
    
    </summary>
    
      <category term="摄影" scheme="https://gandalfliang.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="Timelapse" scheme="https://gandalfliang.github.io/tags/Timelapse/"/>
    
      <category term="Nikon" scheme="https://gandalfliang.github.io/tags/Nikon/"/>
    
      <category term="Guangzhou" scheme="https://gandalfliang.github.io/tags/Guangzhou/"/>
    
      <category term="单反" scheme="https://gandalfliang.github.io/tags/%E5%8D%95%E5%8F%8D/"/>
    
      <category term="Video" scheme="https://gandalfliang.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>WPF 渲染小结</title>
    <link href="https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/"/>
    <id>https://gandalfliang.github.io/2017/09/20/WPF_rendering_perf/</id>
    <published>2017-09-20T16:19:30.000Z</published>
    <updated>2018-05-21T09:05:39.592Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/">D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践</a>最后，提到DropShadowEffect严重影响到D3DImage的渲染性能问题，导致程序在渲染8分屏（8个远端视频）的时候，出现严重的性能下降，渲染卡顿。要知道，在使用原生窗口渲染方案渲染8分屏，CPU占用和内存占用也不过25%和~200Mb，稍差一点，使用D3DImage优化后方案渲染，CPU占用并没有出现多大的跳跃，大约在30%左右。即使是添加了DropShadowEffect的情况下，CPU占用和内存占用好像都没有多大变化；既然在CPU和内存占用都没有多大变化的情况下，WPF渲染卡顿，那肯定（可能吧）是“帧生成”时间过长的锅。 </p><h2 id="帧生成时间"><a href="#帧生成时间" class="headerlink" title="帧生成时间"></a>帧生成时间</h2><p>玩游戏的人都知道，影响游戏帧数的一个关键因素是帧生成时间，帧生成时间过长必定导致游戏FPS下降，游戏不流畅。帧生成时间并不等同帧更新时间，这个需要搞清楚。例如一个游戏锁帧60FPS,那么帧更新时间为1000/60=16.6ms,通常来说，如果你硬件性能足够强劲，那么帧生成时间要小于16.6ms才能保证游戏运行在60FPS的帧率下，否则会掉帧。类似的，WPF的渲染帧率下降可能（无责任猜想）也是同样的因素导致。But why?  </p><h2 id="DropShadowEffect-的锅"><a href="#DropShadowEffect-的锅" class="headerlink" title="DropShadowEffect 的锅"></a>DropShadowEffect 的锅</h2><p>不要误会，DropShadowEffect并没有什么过错。只是在特定情境下，DropShadowEffect（及其他所有Effect类），就是WPF渲染瓶颈的关键： </p><ul><li>将Effect应用到时刻变化的元素</li><li>在应用了Effect的元素上，叠加了其他时刻变化的兄弟元素</li><li>… </li></ul><p>远程会议的问题就是碰到了第二种情景，我们以为只要不直接应用DropShadowEffect到D3DImage这种时刻更新帧的元素上，应该就能避免渲染瓶颈，然而被打脸。<br>说了这么久，好像还是没有说为什么；年轻人，不要这么着急，继续往下看。  </p><h2 id="WPF-的渲染知识两则"><a href="#WPF-的渲染知识两则" class="headerlink" title="WPF 的渲染知识两则"></a>WPF 的渲染知识两则</h2><ul><li>当WPF在渲染一个窗口的时候，它只更新需要更新的区域，称为脏区（DirtyRect）。</li><li>显存的占用与渲染面积成正相关</li></ul><p>使用下面这个例子来模拟导致问题的场景：<br><img src="http://omg3ewm0l.bkt.clouddn.com/orgin_gif.gif" alt=""><br>左边是应用了DropShadowEffect的Grid,中间是应用ColorAnimation的Grid,右边是3个视频渲染。暂时来说，情况看起来还是可以的，没有出现明显的渲染卡顿，整个界面的渲染都维持在一个比较高的帧数。<br><img src="http://omg3ewm0l.bkt.clouddn.com/origin_gif.gif" alt=""><br>那么，将中间的元素叠加在左边的元素上看看：<br><img src="http://omg3ewm0l.bkt.clouddn.com/overlay_lag.gif" alt=""><br>问题出现了，帧率下降严重,视频出现卡顿，ColorAnimation变得不平滑：<br><img src="http://omg3ewm0l.bkt.clouddn.com/overlay_gif.gif" alt=""><br>在这两种情况下，脏区数量都是一样的，分别是始终变化的ColorAnimation Grid和视频区，唯一不同的是，ColorAnimation Grid的位置变了，与应用了DropShadowEffect的Grid部分重叠了，这导致每帧渲染多了一个HW IRT(hardware intermediate render target)，对于WPF来说，HW IRT是一个代价高昂的渲染过程，比它更惨的是SW IRT,如果你的WPF程序在渲染过程中出现多个这种渲染过程，那么可以肯定你的程序需要完成大量的工作来渲染你的程序。</p><h2 id="那么，什么是IRT"><a href="#那么，什么是IRT" class="headerlink" title="那么，什么是IRT?"></a>那么，什么是IRT?</h2><p>Intermediate Render Target。在现代的图形处理单元(GPU)中，我们可以将我们要进行渲染的内容先在Render Target中渲染，然后像素着色器可以通过处理这个Render Target来添加特定的效果，这个过程完成后才将处理完的数据储存到后台缓存（Back Buffer)，这个时候渲染线程（Render Thread)可以将back buffer拷贝到前台缓存（Front Buffer)进行显示。对应到上面的例子，动态元素在拥有DropShadowEffect的元素上刷新，引起脏区更新，这个脏区有关DropShadwoEffect，DropShadowEffect需要像素着色器渲染指令（因为它本身就是由HLSL创建的），嘣！！！，IRT就来了。但是，IRT在一次渲染中是很正常的啊，有些WPF程序在一次渲染中可能存在几个IRT都不会引起这么明显的性能下降。4K是性能的试金石，要知道，我们的程序是运行在4K下的，变化的脏区面积足够大，才引起了显著的性能下降，而且，不要忘了，WPF在使用像素着色器时有天生的缺陷，这篇<a href="https://jeremiahmorrill.wordpress.com/2011/02/14/a-critical-deep-dive-into-the-wpf-rendering-system/" target="_blank" rel="noopener">文章</a>有详细说明,其中提到的关键一点： </p><blockquote><p>WPF has an extensible pixel shader API, along with some build in effects.  This allows developers to really add some very unique effects to their UI.  In Direct3D when you apply a shader to an existing texture, it’s very typical to use an intermediate rendertarget…after all you can’t sample from a texture you are writing to!  WPF does this also, but unfortunately it will create a totally new texture EACH FRAME and destroy it when it’s done.  Creating and destroying GPU resources is one of the slowest things you can do on a per frame basis.  I wouldn’t even typically do this with system memory allocations of that size. There would be a considerable performance increase on the use of shaders if somehow these intermediate surfaces can be reused.  If you’ve ever wondered why you get noticeable CPU usage with these hardware accelerated shaders, this is why.  </p></blockquote><p>至此，WPF的渲染相关文章结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章&lt;a href=&quot;https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/&quot;&gt;D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践&lt;/a&gt;最后，提到DropShadowEffect严
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="渲染" scheme="https://gandalfliang.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
      <category term="Profiling" scheme="https://gandalfliang.github.io/tags/Profiling/"/>
    
      <category term="Perforator" scheme="https://gandalfliang.github.io/tags/Perforator/"/>
    
  </entry>
  
  <entry>
    <title>D3DImage - 它能做啥、解决了什么问题、有哪些瓶颈、怎么最佳实践</title>
    <link href="https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/"/>
    <id>https://gandalfliang.github.io/2017/09/11/D3DImageInDepth/</id>
    <published>2017-09-11T16:19:30.000Z</published>
    <updated>2018-05-21T09:05:39.591Z</updated>
    
    <content type="html"><![CDATA[<p>D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource<a href="https://msdn.microsoft.com/en-us/library/system.windows.interop.d3dimage.aspx" target="_blank" rel="noopener">对象</a>，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 </p><p>年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。<br><a id="more"></a></p><h2 id="什么是AirSpace问题"><a href="#什么是AirSpace问题" class="headerlink" title="什么是AirSpace问题"></a>什么是AirSpace问题</h2><p>这是一个很复杂的问题，涉及到整个WPF的<a href="https://blogs.msdn.microsoft.com/dwayneneed/2013/02/26/mitigating-airspace-issues-in-wpf-applications/" target="_blank" rel="noopener">渲染机制</a>，简单的来说，就是对于WPF窗口的子窗口，其并不是由父窗口负责渲染的，而是由其自己负责自己的渲染，子窗口不能像其他元素一样由父元素来进行布局、渲染（这很好理解），因此，如果我们要在一个WPF窗口中承载另外一个子窗口，那么其渲染并不受父窗口控制，它会渲染在父窗口所有元素之上，这就是导致上面提到的需要用Popup UI来规避Airspace问题的原因。那么问题来了，我为什么要在一个窗口里面渲染另外一个窗口？这不科学。这的确是一个不科学的操作，因为没人会这样做，除非你需要和DirectX内容打交道，特别是对于在WPF做多媒体应用开发的程序员，WPF和DirectX内容的交互 是一个不可避免的问题（虽然我觉得用WPF做多媒体应用本身就存在问题，但这不在本篇文章讨论的范围）。不仅是DirectX内容，在WPF中承载WinForm控件也有同样的问题，为了解决这种问题，微软曾在.Net Framework 4.5的某个预览版（如果没记错的话）中提供了对应的解决方案，但是在正式版中并没有保留，很可惜。</p><h2 id="WPF多媒体程序开发的好帮手-D3DImage"><a href="#WPF多媒体程序开发的好帮手-D3DImage" class="headerlink" title="WPF多媒体程序开发的好帮手 - D3DImage"></a>WPF多媒体程序开发的好帮手 - D3DImage</h2><p>D3DImage就是一个全新的ImageSource，你可以完全根据你对ImageSource的理解来使用它<a href="https://gandalfliang.github.io/2017/06/11/D3DImageInWPF/">D3DImage</a>。为什么说它是WPF多媒体程序的好帮手？正如我上面提到的，我不觉得WPF是多媒体应用开发的第一选择，多媒体应用是一种性能敏感的程序类型，先不说使用WPF你很难触碰到底层的渲染机制，进行调优；而且，你不能原生访问Direct3D接口，即使，至少对于Windows平台下，多媒体内容大多都使用Direct3D API来进行渲染、绘制（更不用说OpenGL了，其对于WPF来说几乎就是一个不可能的选项）。因此我们需要D3DImage，其为你在WPF中使用Direct3D接口和内容提供了一种可能，尽管那是一种不那么直观的方式。<br>说到底，我们需要解决的问题是将Direct3D原生渲染的内容，以一种WPF熟悉的，原生的方式渲染在WPF上。在D3DImage之前，你只能直接渲染在窗口上，因为窗口是Direct3D渲染设备的必须参数。而D3DImage，不要误会，它并不是可以让Direct3D不用窗口进行渲染，而是为Direct3D渲染的内容提供了一个“通道”，这个”通道”使WPF可以将ID3DDevice上的渲染表面ID3DSurface更新到其渲染线程中（这种说法并不准确，但是你可以先这样理解，至于它们是怎样”共享“表面的，我们以后再谈）。</p><h2 id="一切看起来都是那么完美，但是…"><a href="#一切看起来都是那么完美，但是…" class="headerlink" title="一切看起来都是那么完美，但是…"></a>一切看起来都是那么完美，但是…</h2><p>可以想象的到，D3DImage方式并不能提供比肩原生渲染的性能，不论是CPU占用还是内存占用。特别是当你需要兼顾Windows XP的时候，那性能就更加难看了。WPF虽然说是支持硬件加速的一个框架，但是它有<a href="https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/">原生缺陷</a>，这篇文章描述了一些深入的问题。要知道，在Windows Vista之前，即Windows Xp，只能使用D3D9接口创建D3dDevice，我们甚至不能使用D3D9Ex接口，对于D3DImage来说，这是一个很大的性能损耗，因为由D3D9接口创建的D3dSurface与WPF的D3Dimage渲染过程中存在一个很恶心的过程，WPF需要将显存中的D3DSurface内容拷贝回系统内存，处理完后再拷贝回显存进行渲染，毫无疑问会导致CPU占用和内存占用上升。我们使用剪辑师来做一个实验，在关闭硬件加速的情况下，对比使用两种接口来创建渲染表面的性能表现：<br>在关闭硬件加速的情况下，使用剪辑师播放一个2K分辨率的视频在不同时刻的CPU占用：<br><img src="http://omg3ewm0l.bkt.clouddn.com/image2017-9-11_17-34-12.png" alt=""> </p><p>可以看出存在明显的性能差别，在使用D3DEx接口创建渲染表面进行和WPF的交互操作时，并不存在上面提到的显存→系统内存拷贝问题，其直接在显存中进行拷贝，这样会降低CPU损耗。即使这样，它也不能提供比原生窗口渲染更好的性能，这在我们意料之内。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>不要支持Windows XP</li><li>使用D3D9Ex以上接口来创建你要在D3DImage承载的Direct3D内容</li><li>不要在UI上使用DropShadowEffect，一点都不可以<br>关于这一点，又是一个可以深究的问题，但是这里就先简单的说一下。在远程会议的开发中，我们在渲染8分屏的时候，发现使用D3DImage进行视频渲染的时候，性能表现远远低于原生窗口渲染的方式，虽然知道D3DImage性能上与原生渲染存在差距，但是也不可能相差这么远。刚开始的时候我并没有怀疑DropShadowEffect，因为我知道它会带来性能问题，因此我还故意将其应用到一个空的Grid上，而不是直接应用到D3DImage上，而且这个Grid和Image并不是父子关系，在我的印象中，这样可以规避将整个D3DImage的像素数据进行DropShadowEffect的管道数据处理（DropShadowEffect本质是一个像素着色器，像素着色器是一个高性能组件，对于现代3D游戏来说，是一个必不可少的组件，但是<a href="https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/">这篇文章</a>已经提到，WPF里的像素着色器并不完全是那么一回事），按理说，性能瓶颈并不应该出现在这里，然而，它的确是这里，原因是啥？我也不清楚，或许以后有结论之后我们再开一篇文章来谈谈。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;D3dImage，.Net Framework 3.5 之后，微软提供的一个全新的ImageSource&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.windows.interop.d3dimage.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对象&lt;/a&gt;，可以在WPF中很好的呈现DirectX内容；在此之前，你只能将DirectX内容直接渲染在Windows窗口之上，这必然引起令人头疼的AirSpace问题，为了在这些内容上面添加我们习以为常的WPF UI 元素，你只能使用Popup来承载这些内容，完全丧失WPF UI开发的灵活性，且有经验的WPF程序员都知道一个事实：WPF Popup就是一个深坑 - 你需要手动处理各种显示隐藏问题、因为其导致的焦点问题，显示层级问题以及最令人头疼的性能问题，特别是在4K屏幕下，因为我们都知道，Popup就是一个Window，为了解决Airspace问题而使用Popup来承载UI必定需要使其AllowTransparency=True，这就引起了另外一个问题，透明窗口占用内存与其面积成正相关，在4K屏幕下，你可能将整个程序大部分的内存占用贡献给了这些Popup UI。说了这么多，好像在诉控Popup有多么的垃圾（它的确如此，如果在做大量的UI容器时）。 &lt;/p&gt;
&lt;p&gt;年轻人，如果你觉得Airspace问题真的没有办法解决了，只能用Popup这种技术手段来规避了，那么听老人一句话，不要浪费时间在Popup上了，因为你在前期投入的时间来规避种种Popup UI导致的问题以及各种你意想不到的Bug，到最后总会碰到解决不了，完全不能规避的情况，从而导致整个Popup UI替换方案完全失败的情形。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
      <category term="D3DImage" scheme="https://gandalfliang.github.io/tags/D3DImage/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 入门</title>
    <link href="https://gandalfliang.github.io/2017/08/18/FFmpegCookbook_1/"/>
    <id>https://gandalfliang.github.io/2017/08/18/FFmpegCookbook_1/</id>
    <published>2017-08-18T16:19:30.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>废话少说，要解码一个视频帧，你需要这样做：</p><div id="flowchart-0" class="flow-chart"></div><p>获得帧数据后，用SDL还是直接用D3d渲染，那就看你自己了。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Starte=>end: Endo=>operation: 初始化av_register_all;avformat_network_init;o1=>operation: 打开文件:avformat_open_input;o2=>operation: 获取stream并打开符合的codec :avformat_find_stream_info;avcodec_find_decoder;avcodec_open2;o3=>operation: av_read_frame;avcodec_decode_video2;st->o->o1->o2->o3->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"line-height":30}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话少说，要解码一个视频帧，你需要这样做：&lt;/p&gt;
&lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt;

&lt;p&gt;获得帧数据后，用SDL还是直接用D3d渲染，那就看你自己了。&lt;script src=&quot;https://cdnjs.cl
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="FFmpeg" scheme="https://gandalfliang.github.io/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="https://gandalfliang.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="解码" scheme="https://gandalfliang.github.io/tags/%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>D3DImage in WPF</title>
    <link href="https://gandalfliang.github.io/2017/06/11/D3DImageInWPF/"/>
    <id>https://gandalfliang.github.io/2017/06/11/D3DImageInWPF/</id>
    <published>2017-06-12T03:10:50.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在.Net Framework 3.5 SP1中，微软在WPF中提供了D3DImage对象，D3DImage是一个ImageSource，这可以让我们在WPF原生的D3D Surface上渲染Direct3D Surface，大大提高了WPF和DirectX内容的交互性。<br>在此之前，要想在WPF上渲染DirectX的内容，只能让DirectX直接渲染到窗口上，这样会造成不可避免的Airspace问题，因为DirectX内容要时刻刷新重绘，导致WPF窗口上的其他内容被覆盖，表现就是DirectX内容始终在窗口最顶层。<br>正如前面所说，D3DImage是一个ImageSource，在WPF中，这意味着，我们可以将一个3D场景变成一个Image对象的Source，或者构建一个ImageBrush，这意味这D3D Surface可以渲染到WPF中任意一个以Brush进行渲染的元素上，例如图片，文本前景色，元素背景色等等。<br>如下，就是一个典型的应用D3DImage的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d3dimg.IsFrontBufferAvailable)</span><br><span class="line">&#123;</span><br><span class="line">    IntPtr pSurface = IntPtr.Zero;</span><br><span class="line">    pSurface = _view.GetBackBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSurface != IntPtr.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">        d3dimg.Lock();</span><br><span class="line">        d3dimg.SetBackBuffer(D3DResourceType.IDirect3DSurface9,pSurface);</span><br><span class="line">        _view.Draw();</span><br><span class="line">        d3dimg.AddDirtyRect(<span class="keyword">new</span> Int32Rect(<span class="number">0</span>, <span class="number">0</span>, d3dimg.PixelWidth, d3dimg.PixelHeight));</span><br><span class="line">        d3dimg.Unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要Direct3D内容渲染的Surface接口指针即可，如上面的pSurface。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在.Net Framework 3.5 SP1中，微软在WPF中提供了D3DImage对象，D3DImage是一个ImageSource，这可以让我们在WPF原生的D3D Surface上渲染Direct3D Surface，大大提高了WPF和DirectX内容的交互性。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
      <category term="D3DImage" scheme="https://gandalfliang.github.io/tags/D3DImage/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】There Is No Thread</title>
    <link href="https://gandalfliang.github.io/2017/05/02/ThereIsNoThread/"/>
    <id>https://gandalfliang.github.io/2017/05/02/ThereIsNoThread/</id>
    <published>2017-05-02T22:14:58.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这里并没有线程"><a href="#这里并没有线程" class="headerlink" title="这里并没有线程"></a>这里并没有线程</h2><p>原文地址： <a href="http://blog.stephencleary.com/2013/11/there-is-no-thread.html" target="_blank" rel="noopener">http://blog.stephencleary.com/2013/11/there-is-no-thread.html</a></p><hr><p>最纯粹的async形式中存在一个重要的真相：这里并没有线程（或者不存在新建的线程）<br>举不胜数的反对者哭喊道：“不！如果我正在等待一个操作，那一定存在一个线程在等待这个操作！它可能是一个线程池中的线程。或者是系统线程！或者是其他类似设备驱动的东西…”。</p><p>不要听从那些哭喊的人。如果那些async操作是纯粹的，那么这里将不会存在线程。</p><p>那些持怀疑态度的人并没有被说服。让我们来娱乐一下他们。</p><p>我们可以一路跟踪一条异步操作指令到硬件层面，特别留意其中的.Net部分和设备驱动部分。为了简化这部分描述，我们排除掉部分中间层的细节，但是这应该不会让我们偏离真相。</p><p>思考一个通用的“写”操作（写一个文件、网络流、USB等等）。我们的代码很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">async</span> <span class="keyword">void</span> Button_Clicked(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    byte[] data = ...</span><br><span class="line">    <span class="keyword">await</span> myDevice.WriteAsync(data, <span class="number">0</span>, data.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们早就知道，UI线程并不会被await操作阻塞。那么问题来了：这里是不是存在另外一个线程，它牺牲自己所以UI线程才能存活？  </p><p>抓住我的手，我们要潜的更深一点。</p><p>第一站：类库（例如，查看BCL代码）。我们假设 WriteAsync 是用 .Net 标准的 P/Invoke 异步 I/O 操作实现的。所以，这个操作在设备的句柄上开始了一个Win32的重叠I/O操作。</p><p>系统紧接着转到设备驱动并让设备开始写操作。它首先构造一个表示写请求的对象，这被称为I/O Request Packet(IRP)。设备驱动获得这个IRP并向设备发起命令来写对应的数据。如果设备支持Direct Memory Access(DMA)，这个操作就像向设备寄存器中写入缓存地址一样简单。这是设备驱动能做的所有事情；它使得IRP进入“等待”并转回到系统。</p><p><img src="http://blog.stephencleary.com/assets/Os1.png" alt=""></p><p>事实的核心：当处理IRP时，设备驱动不允许堵塞。这意味着，如果IRP不能立即完成，那么它一定要异步执行。这对于同步API也一样成立。在设备驱动这一层，所有（重要的）请求都是异步的。<br>随着IRP进入“等待”状态，系统通过返回一个未完成的Task给刚才堵塞的async按钮点击事件，然后UI线程继续执行。<br>我们深入追踪到系统底层的写操作，直至物理设备。<br>现在，写操作正在执行，那有多少线程在处理它呢？  </p><h3 id="一个都没有"><a href="#一个都没有" class="headerlink" title="一个都没有"></a>一个都没有</h3><p>这里并没有设备驱动线程，系统线程，BLC线程或者线程池线程在处理那个写操作。<strong>这里根本就没有线程</strong><br>现在，我们看一下对应的回复（Response)。<br>写请求开始片刻，设备完成了写操作，他通过中断（Interrupt)通知CPU。<br>设备驱动的Interrupt Service Routine(ISR)对这个中断做出反应。中断是CPU层的时间，它会临时从当前CPU所运行的线程中获得CPU的控制权。你可以认为ISR是在“借用”当前正在运行的线程，但是我更倾向于认为ISR在更底层中执行，底层到根本不存在线程这个概念的水平。或者说它在所有线程之下。<br>无论如何，ISR已经被妥当的进行了写操作，它做的所有事情就是告诉设备“谢谢你的中断请求”并且将一个Deferred Procedure Call(DPC)入队（queue)。<br>当CPU被中断“骚扰”完之后，它会转向它的DPC。DPC也是在一个不能直接用线程描述的底层水平。和ISR一样，DPC直接在CPU上执行，在线程系统之下。<br>DPC获取代表写操作的ISR并将其标志成“完成”。然而，那么“完成”状态只存在系统层；必须要通知到进程自己拥有的内存空间。所以系统会入队一个special-kernel-mode Asynchronous Procedure Call(APC)给拥有HANDLE的线程。<br>因为上述提到的类库/BLC使用的是标准P/Inovke Overlapped I/O 系统，它早就注册了I/O Completion Port(IOCP)的句柄，这个句柄是线程池的一部分。所以，一个I/O线程池线程被短暂的“借用”来执行APC,通过它来通知task已经完成。<br>现在task捕获了UI线程的上下文，它不直接从线程池线程中返回async方法，相反，它将async方法后续的执行加入到UI线程的上下文，当UI线程执行到这里的时候就会继续执行这部分代码。<br>所以，当请求发生时，我们可以看到这里并没有线程。当请求完成时，大量的线程被“借用”或者短暂暂存到它们那里。这些工作大约在一毫秒（运行在线程池的APC)或者低到一微秒（例如ISR)。但是这里并没有线程因为等待请求完毕而被堵塞。</p><p><img src="http://blog.stephencleary.com/assets/Os2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这里并没有线程&quot;&gt;&lt;a href=&quot;#这里并没有线程&quot; class=&quot;headerlink&quot; title=&quot;这里并没有线程&quot;&gt;&lt;/a&gt;这里并没有线程&lt;/h2&gt;&lt;p&gt;原文地址： &lt;a href=&quot;http://blog.stephencleary.com/2013/
      
    
    </summary>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://gandalfliang.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="async/await" scheme="https://gandalfliang.github.io/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>Mandelbrot Set - 在复平面上绘制曼德博集合</title>
    <link href="https://gandalfliang.github.io/2017/03/19/Mandelbrot/"/>
    <id>https://gandalfliang.github.io/2017/03/19/Mandelbrot/</id>
    <published>2017-03-19T17:58:27.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>曼德博集合（Mandelbrot set，或译为曼德布洛特复数集合）是一种在复平面上组成分形的点的集合，以数学家本华·曼德博的名字命名。曼德博集合与朱利亚集合有些相似的地方，例如使用相同的复二次多项式来进行迭代。(<a href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88" target="_blank" rel="noopener">维基百科</a>)</p><p>其中的迭代公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(Zn+1)=Zn^2+c</span><br></pre></td></tr></table></figure></p><p>其中，c是任意复数。我们知道c可以表示为：c=x+y*i。根据复数的定义，i^2=-1。因此，我们通过将二维平面当作复平面，x是其中复数的实部R,y是复数的虚部Im。根据上面的额迭代公式，使用OpenCL对每个点进行同步的迭代，快速得到曼德博集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//openCL代码</span></span><br><span class="line">kernel <span class="keyword">void</span> Mandelbrot(</span><br><span class="line">    global write_only int* result,</span><br><span class="line">    int width,<span class="comment">//图片宽度</span></span><br><span class="line">    int height,<span class="comment">//图片高度</span></span><br><span class="line">    float minReal,<span class="comment">//最小实部</span></span><br><span class="line">    float maxReal,<span class="comment">//最大实部</span></span><br><span class="line">    float minIma,<span class="comment">//最小虚部</span></span><br><span class="line">    float maxIma,<span class="comment">//最大虚部</span></span><br><span class="line">    int max_iter)<span class="comment">//最大迭代次数，当迭代这么多次后，该复数还没逃逸，则认为其在曼德博集合中</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取GPU当前线程的编号，可以将这个物化为图片当前位置的一个像素点的计算方位</span></span><br><span class="line">    int tX = global_get_id(<span class="number">0</span>);</span><br><span class="line">    int tY = global_get_id(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算坐标的刻度值</span></span><br><span class="line">    float real_inter = (maxReal - minReal) / width;</span><br><span class="line">    float ima_inter = (maxIma - minIma) / height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程（像素点）在复平面的位置</span></span><br><span class="line">    int cX = minReal + tx * real_inter;</span><br><span class="line">    int cY = minIma + (height - tY) * ima_inter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    float zX=<span class="number">0</span>;</span><br><span class="line">    float zY=<span class="number">0</span>;</span><br><span class="line">    int iter=<span class="number">0</span>;</span><br><span class="line">    float length_sqr=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        iter++;</span><br><span class="line">        float temp = zX * zX - zY * zY + cX;</span><br><span class="line">        zY = <span class="number">2</span> * zX * zY + cY;</span><br><span class="line">        zX = temp;</span><br><span class="line"></span><br><span class="line">        length_sqr=zX * zX + zY * zY;<span class="comment">//在GPU上，根号运算要慢得多</span></span><br><span class="line">    &#125;<span class="comment">//根据曼德博集合的性质，我们知道集合的中的任意一个复数|z|&lt;2,因此对于复数z=tX+tY*i,|z|^2=tX*tX+tY*tY&lt;4</span></span><br><span class="line">    <span class="keyword">while</span>(length_sqr &lt; <span class="number">4</span> &amp;&amp; iter &lt; max_iter);</span><br><span class="line">    </span><br><span class="line">    int loc = tY * width + tX;</span><br><span class="line">    result[loc] = iter;<span class="comment">//通过迭代值来标识当前位置的像素点是否属于曼德博集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种每个点都可以独立迭代运算，互不干扰的特性，最适合用GPU来进行计算的了，因此，通过OpenCL,我们可以快速得到想要的数据。使用 Surface Book 的内置显卡nVidia 520计算3000*3000规模,迭代512次的数据，可以在30ms内完成。如下是通过得到的数据生成的一些配色图：</p><p><img src="http://omg3ewm0l.bkt.clouddn.com/Mandelbrot_xray.jpg" alt="X光效果"></p><p><img src="http://omg3ewm0l.bkt.clouddn.com/manbelrot_green.jpg" alt=""></p><p>复数与曼德罗集合的相关信息，可参考：<a href="https://msdn.microsoft.com/zh-cn/library/jj635753(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/jj635753(v=vs.85).aspx</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曼德博集合（Mandelbrot set，或译为曼德布洛特复数集合）是一种在复平面上组成分形的点的集合，以数学家本华·曼德博的名字命名。曼德博集合与朱利亚集合有些相似的地方，例如使用相同的复二次多项式来进行迭代。(&lt;a href=&quot;https://zh.wikipedia.
      
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="曼德博集合" scheme="https://gandalfliang.github.io/tags/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88/"/>
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="高性能计算" scheme="https://gandalfliang.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>OpenCL with CLOO</title>
    <link href="https://gandalfliang.github.io/2017/03/11/OpenCLwithCLOO/"/>
    <id>https://gandalfliang.github.io/2017/03/11/OpenCLwithCLOO/</id>
    <published>2017-03-12T02:19:30.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sourceforge.net/projects/cloo/" target="_blank" rel="noopener">CLOO</a> 是一个对 OpenCL 的 .Net 封装，可以让 .Net/Mono 程序充分使用 OpenCL 的优势，易用、开源。</p><p>今天用 OpenCL 中的 “Hello World” 程序 - 矩阵乘法，来简单介绍一下 OpenCL。</p><p>OpenCL 是一个开放的工业标准，既然是开放的，那么，所有厂商就可以提供自己的实现，例如英特尔，英伟达等等。也正因为如此，也导致在同一台机器上可能存在多个支持不同版本的硬件。例如，英伟达的GPU到现在也才支持 OpenCL 1.2 版本，但是OpenCL都已经出到2.x版本了。</p><p>我们可以查看当前设备中，有哪些厂商提供了 OpenCL 的支持，以及运算平台是啥。例如，在 Surface Book (with Nvidia GPU) 上，我们调用以下代码看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有平台</span></span><br><span class="line"><span class="keyword">var</span> platforms = ComputePlatform.Platforms;</span><br><span class="line"></span><br><span class="line">foreach(<span class="keyword">var</span> platform <span class="keyword">in</span> platforms)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($<span class="string">"&#123;platform.Name&#125;,&#123;platform.Version&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取该平台下的计算设备</span></span><br><span class="line">    <span class="keyword">var</span> devices = platform.QueryDevices();</span><br><span class="line">    foreach(<span class="keyword">var</span> device <span class="keyword">in</span> devices)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($<span class="string">"    Device:&#123;device.Name&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intel(R) OpenCL, OpenCL 2.0</span><br><span class="line">    Device:Intel(R) HD Graphics 520</span><br><span class="line">    Device:Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz</span><br><span class="line"></span><br><span class="line">NVIDIA CUDA, OpenCL 1.2 CUDA 8.0.0</span><br><span class="line">    Device:GeForce GPU</span><br></pre></td></tr></table></figure><p>可以看出这台机器上有两个支持 OpenCL 的平台，英特尔的CPU和英伟达的GPU，其中，INTEL CPU 里又有两个计算设备 CPU 和集成的核显 HD520。<br>毫无疑问，在 OpenCL 上，英伟达的GPU可以提供比 Intel CPU 高得多的性能，毕竟，GPU的流处理器数量要比CPU上那可怜的核显上的要多得多。</p><h2 id="主机代码-host-和核心代码-kernel"><a href="#主机代码-host-和核心代码-kernel" class="headerlink" title="主机代码(host)和核心代码(kernel)"></a>主机代码(host)和核心代码(kernel)</h2><p>OpenCL分有主机代码和核心代码，相对于核心代码，主机代码用于对环境进行初始化，例如配置运行平台，计算设备等的。而核心代码，就是运行在指定计算设备的代码，例如GPU。这就好像DirectX上的HLSL一样，HLSL的代码只运行在GPU上。</p><p>OpenCL是一个动态编译的框架，就是说核心代码是在运行时才被编译的，程序运行时，在核心代码还没被编译前我们都可以更改核心代码。</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>矩阵乘法，以最普通的算法来进行计算，是时间复杂度为O(n^3)的算法，时间都花在做重复的加法和乘法运算，这种情景最适合用GPU来进行处理了。<br>先来看一下常规的算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设为两个规模为Rank的方形矩阵</span></span><br><span class="line"><span class="keyword">int</span> matrixA[Rank][Rank];</span><br><span class="line"><span class="keyword">int</span> sum[Rank][Rank];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Rank; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Rank; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Rank; k++)</span><br><span class="line">                sum[i][j] += matrixA[i][k] * matrixA[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：</p><p>我们要让这段代码在GPU上快速运行，当然，我们不能直接就让这段代码作为我们的OpenCL核心代码，因为这样并不能发挥GPU同步计算的优势。我们让想办法将整个流程拆分为各个可以同时进行的子运算，让GPU同步并行计算，以此降低计算耗时。</p><p>如下，是这个程序的OpenCL核心代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel <span class="keyword">void</span> MatrixMul(</span><br><span class="line">global write_only int* result,</span><br><span class="line">global read_only int* matrix,</span><br><span class="line">int rank)</span><br><span class="line">&#123;</span><br><span class="line">    int gx=get_global_id(<span class="number">0</span>);</span><br><span class="line">    int gy=get_global_id(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    int loc=gx*rank+gy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;rank;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int leftLoc=gx*rank+i;</span><br><span class="line">        int rightLoc=i*rank+gy;</span><br><span class="line">        result[loc]+=matrix[leftLoc]*matrix[rightLoc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是实际上跑在GPU上的代码。前面提到，OpenCL是动态编译的框架，这段代码你可以放在任何一个文本文件中，但是有一个注意的是，只有kernel标志的函数才是程序入口。</p><p>而下面的就是主机代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Runtime.InteropServices;</span><br><span class="line">using Cloo;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line"></span><br><span class="line">namespace MatrixDemo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix_mul_opencl(<span class="number">500</span>);</span><br><span class="line">            Matrix_mul_opencl(<span class="number">1000</span>);</span><br><span class="line">            Matrix_mul_opencl(<span class="number">1500</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> Matrix_mul_opencl(int r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//选取设备</span></span><br><span class="line">            <span class="keyword">var</span> platform = ComputePlatform.Platforms.FirstOrDefault();</span><br><span class="line">            <span class="keyword">var</span> device = platform.Devices.FirstOrDefault();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关上下文</span></span><br><span class="line">            <span class="keyword">var</span> properties = <span class="keyword">new</span> ComputeContextPropertyList(platform);</span><br><span class="line">            <span class="keyword">var</span> context = <span class="keyword">new</span> ComputeContext(<span class="keyword">new</span>[] &#123; device &#125;, properties, <span class="literal">null</span>, IntPtr.Zero);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//命令队列，用于控制执行的代码</span></span><br><span class="line">            ComputeCommandQueue commands = <span class="keyword">new</span> ComputeCommandQueue(context, context.Devices[<span class="number">0</span>],</span><br><span class="line">                ComputeCommandQueueFlags.None);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取opencl代码</span></span><br><span class="line">            <span class="keyword">var</span> code = File.ReadAllText(<span class="string">"matrix.cl"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译</span></span><br><span class="line">            <span class="keyword">var</span> program = <span class="keyword">new</span> ComputeProgram(context, code);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                program.Build(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, IntPtr.Zero);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建核心代码，就是cl代码中以kernel标识，函数签名为MatrixMul的函数</span></span><br><span class="line">            <span class="keyword">var</span> kernel = program.CreateKernel(<span class="string">"MatrixMul"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//矩阵规模</span></span><br><span class="line">            int rank = r;</span><br><span class="line">            <span class="comment">//储存计算结果的数组</span></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> ComputeBuffer&lt;int&gt;(context, ComputeMemoryFlags.WriteOnly, rank * rank);</span><br><span class="line">            <span class="keyword">var</span> matrix = CreateMatrix(context, rank);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建的核心代码函数以这种方式来传参</span></span><br><span class="line">            kernel.SetMemoryArgument(<span class="number">0</span>, result);</span><br><span class="line">            kernel.SetMemoryArgument(<span class="number">1</span>, matrix);</span><br><span class="line">            kernel.SetValueArgument(<span class="number">2</span>, rank);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine($<span class="string">"运行平台: &#123;platform.Name&#125;\n运行设备： &#123;device.Name&#125;\n矩阵规模: &#123;rank&#125;x&#123;rank&#125;"</span>);</span><br><span class="line"></span><br><span class="line">            Stopwatch sw = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行代码</span></span><br><span class="line">            commands.Execute(kernel, <span class="literal">null</span>, <span class="keyword">new</span> long[] &#123; rank, rank &#125;, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            int[] resultArray = <span class="keyword">new</span> int[rank * rank];</span><br><span class="line">            <span class="keyword">var</span> arrHandle = GCHandle.Alloc(resultArray, GCHandleType.Pinned);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据</span></span><br><span class="line">            commands.Read(result, <span class="literal">true</span>, <span class="number">0</span>, rank * rank, arrHandle.AddrOfPinnedObject(), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> elapsed = sw.Elapsed;</span><br><span class="line">            Console.WriteLine($<span class="string">"耗时: &#123;elapsed.TotalMilliseconds&#125; ms\n"</span>);</span><br><span class="line"></span><br><span class="line">            arrHandle.Free();</span><br><span class="line"></span><br><span class="line">            kernel.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建实验矩阵</span></span><br><span class="line">        <span class="keyword">static</span> ComputeBuffer&lt;int&gt; CreateMatrix(ComputeContext context, int rank)</span><br><span class="line">        &#123;</span><br><span class="line">            int size = rank * rank;</span><br><span class="line">            int[] datas = <span class="keyword">new</span> int[size];</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                datas[i] = i % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> matrix = <span class="keyword">new</span> ComputeBuffer&lt;int&gt;(context, ComputeMemoryFlags.CopyHostPointer, datas);</span><br><span class="line">            <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">运行平台: NVIDIA CUDA</span><br><span class="line">运行设备： GeForce GTX 1060 6GB</span><br><span class="line">矩阵规模: 500x500</span><br><span class="line">耗时: 28.7764 ms</span><br><span class="line"></span><br><span class="line">运行平台: NVIDIA CUDA</span><br><span class="line">运行设备： GeForce GTX 1060 6GB</span><br><span class="line">矩阵规模: 1000x1000</span><br><span class="line">耗时: 224.5405 ms</span><br><span class="line"></span><br><span class="line">运行平台: NVIDIA CUDA</span><br><span class="line">运行设备： GeForce GTX 1060 6GB</span><br><span class="line">矩阵规模: 1500x1500</span><br><span class="line">耗时: 1024.3869 ms</span><br></pre></td></tr></table></figure></p><p>对于矩阵规模为500x500的计算，耗时28毫秒，1500的规模则需要1024毫秒，这性能，比用常规方法跑在CPU上，耗时要18秒的情况不知道高到哪里去了。但是有个诡异的事情是，在Windows 10上，当我尝试将矩阵规模提升到2000或以上时，opencl会抛出OutOfResource异常，但是相同规模的矩阵乘法运算，用C++ AMP计算跑在相同的设备上却没有问题，恩，或许这个跟英伟达的显卡驱动或者Windows 10的内存机制有关，有空再讲。</p><p>那还有没有更快的方法呢？当然有了，我们下篇文章再谈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/cloo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CLOO&lt;/a&gt; 是一个对 OpenCL 的 .Net 封装，可以让 .Net/Mono 程序充分使用 OpenCL 的优势，易用、开源。&lt;/p&gt;
&lt;p&gt;今天用 OpenCL 中的 “Hello World” 程序 - 矩阵乘法，来简单介绍一下 OpenCL。&lt;/p&gt;
&lt;p&gt;OpenCL 是一个开放的工业标准，既然是开放的，那么，所有厂商就可以提供自己的实现，例如英特尔，英伟达等等。也正因为如此，也导致在同一台机器上可能存在多个支持不同版本的硬件。例如，英伟达的GPU到现在也才支持 OpenCL 1.2 版本，但是OpenCL都已经出到2.x版本了。&lt;/p&gt;
&lt;p&gt;我们可以查看当前设备中，有哪些厂商提供了 OpenCL 的支持，以及运算平台是啥。例如，在 Surface Book (with Nvidia GPU) 上，我们调用以下代码看看：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//获取所有平台&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; platforms = ComputePlatform.Platforms;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foreach(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; platform &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; platforms)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Console.WriteLine($&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;platform.Name&amp;#125;,&amp;#123;platform.Version&amp;#125;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//获取该平台下的计算设备&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; devices = platform.QueryDevices();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foreach(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; device &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; devices)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Console.WriteLine($&lt;span class=&quot;string&quot;&gt;&quot;    Device:&amp;#123;device.Name&amp;#125;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="https://gandalfliang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OpenCL" scheme="https://gandalfliang.github.io/tags/OpenCL/"/>
    
      <category term="CLOO" scheme="https://gandalfliang.github.io/tags/CLOO/"/>
    
      <category term="通用计算" scheme="https://gandalfliang.github.io/tags/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Timelapse</title>
    <link href="https://gandalfliang.github.io/2017/03/07/Timelapse/"/>
    <id>https://gandalfliang.github.io/2017/03/07/Timelapse/</id>
    <published>2017-03-08T01:33:39.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<video src="http://omg3ewm0l.bkt.clouddn.com/timelapse_home_2K.mp4" type="video/mp4" controls="controls" width="100%" height="100%"><br></video><p>4K：<a href="http://omg3ewm0l.bkt.clouddn.com/timelapse_home.mp4" target="_blank" rel="noopener">http://omg3ewm0l.bkt.clouddn.com/timelapse_home.mp4</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;video src=&quot;http://omg3ewm0l.bkt.clouddn.com/timelapse_home_2K.mp4&quot; type=&quot;video/mp4&quot; controls=&quot;controls&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;br&gt;&lt;/vi
      
    
    </summary>
    
      <category term="摄影" scheme="https://gandalfliang.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="Timelapse" scheme="https://gandalfliang.github.io/tags/Timelapse/"/>
    
      <category term="Nikon" scheme="https://gandalfliang.github.io/tags/Nikon/"/>
    
      <category term="Guangzhou" scheme="https://gandalfliang.github.io/tags/Guangzhou/"/>
    
      <category term="单反" scheme="https://gandalfliang.github.io/tags/%E5%8D%95%E5%8F%8D/"/>
    
      <category term="2K" scheme="https://gandalfliang.github.io/tags/2K/"/>
    
      <category term="Video" scheme="https://gandalfliang.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>深挖 WPF 渲染系统</title>
    <link href="https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/"/>
    <id>https://gandalfliang.github.io/2017/03/03/ACriticalDeepDiveIntoTheWPFRenderingSystem/</id>
    <published>2017-03-03T20:30:30.000Z</published>
    <updated>2018-02-12T07:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇2011年的文章，原地址在 <a href="https://jeremiahmorrill.wordpress.com/2011/02/14/a-critical-deep-dive-into-the-wpf-rendering-system/" target="_blank" rel="noopener">A Critical Deep Dive into the WPF Rendering System</a>，个人认为到现在都可以给WPF程序开发人员作为一个参考，里面详细讲述了 WPF 这个号称从底层支持硬件加速的 UI 框架为什么有时候看起来并不是那么回事的原因。以下是正文。</p><hr><p>刚开始我并不认为我会发表这篇文章。在被一些我高度重视的人说服后，我决定要发表这篇文章。那些深入投入微软UX平台的程序员应该更加深入了解这个平台内部是怎么工作的，当他们撞到一睹石墙的时候，他们可以清晰了解到问题所在并且更加准确地沟通他们希望平台做出怎样的改变。</p><h2 id="我相信-WPF-和-Silverlight-是精心打造的技术，但是…"><a href="#我相信-WPF-和-Silverlight-是精心打造的技术，但是…" class="headerlink" title="我相信 WPF 和 Silverlight 是精心打造的技术，但是…"></a><strong>我相信 WPF 和 Silverlight 是精心打造的技术，但是…</strong></h2><p>如果这几个月你有关注我的Twitter，你也许会发现我一直在吐槽WPF（Silverlight也一样）的性能。为什么我会这样做？毕竟这些年我花费了大量的时间为这个平台布道、写库、社区帮助和指导等等。准确来讲，我个人全身投入到这个平台里面，我希望这个平台越来越好。</p><h2 id="性能，性能，性能"><a href="#性能，性能，性能" class="headerlink" title="性能，性能，性能"></a><strong>性能，性能，性能</strong></h2><p>当在开发沉浸式的、消费者导向的UX的时候，性能是你第一位的特性。性能是你添加其他特性的前提和基础。有多少次因为UI太卡你需要缩小UI的规模？有多少次因为这个技术做不到所以你需要丢弃“开创性的UX模型”？有多少次你告诉客户他们需要一个2.4GHz的四核CPU才能获得全部的体验？我一直以来都被客户问，为什么在PC上拥有4倍于iPad的性能的情况下，WPF程序却做不到像iPad应用那般流畅？<br><a id="more"></a></p><h2 id="我觉得-WPF-是有应用硬件加速技术的？告诉我为什么你觉得它效率低。"><a href="#我觉得-WPF-是有应用硬件加速技术的？告诉我为什么你觉得它效率低。" class="headerlink" title="我觉得 WPF 是有应用硬件加速技术的？告诉我为什么你觉得它效率低。"></a><strong>我觉得 WPF 是有应用硬件加速技术的？告诉我为什么你觉得它效率低。</strong></h2><p>WPF是有硬件加速的，并且其内部工作的某些部分也是很简洁的。不幸的是，它并没有像它应该能够做的的那样来高效率地使用GPU。它的渲染系统是非常暴力的。我希望在这里解释我为什么这样说。</p><h2 id="分析一个完整的-WPF-渲染流程"><a href="#分析一个完整的-WPF-渲染流程" class="headerlink" title="分析一个完整的 WPF 渲染流程"></a><strong>分析一个完整的 WPF 渲染流程</strong></h2><p>为了分析性能，我们需要知道WPF底层到底在干什么。要做到这个，我使用“PIX”工具，这是DirectX SDK里的一个Direct3D性能分析工具。PIX会加载基于D3D的程序并向所有的Direct3D调用注入钩子来分析和监控程序。</p><p>我创建了一个简单的WPF程序，里面从左到右有两个圆形。每个圆形有相同的填充色（#55F4F4F5)和一个黑色的描边。如下图：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image001_thumb.png" alt=""></p><h2 id="WPF-程序是怎样渲染这个程序的？"><a href="#WPF-程序是怎样渲染这个程序的？" class="headerlink" title="WPF 程序是怎样渲染这个程序的？"></a><strong>WPF 程序是怎样渲染这个程序的？</strong></h2><p>WPF做的第一件事情是清理出一块需要重新绘制的废弃区域。废弃区域的作用是减少发送给GPU管道中输出合并阶段的像素量。我们甚至可以猜测，这样可以减少需要重新进行曲面细分的多边形数量（稍后会提到）。废弃区域清理后我们的帧看起来像这样：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image002_thumb.png?w=511&amp;h=310" alt=""></p><p>接着，WPF做了某些我不能理解的事情。它首先填充了一个顶点缓存区，然后这就好像在废弃区域上绘制了一个四边形。所以现在的帧看起来是这样的（兴奋吧？）：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image003_thumb.png?w=511&amp;h=310" alt=""></p><p>下一步，它在CPU上对一个圆形进行曲面细分。曲面细分，你或许已经听过，但是重要的是它将我们100X100的圆形多边形变成了一堆三角形。会这样的原因是1）三角形是GPU渲染的基本单位。2）对一个圆形进行曲面细分可能只是几百个顶点，所有它比在CPU上对10000个反锯齿的像素进行栅格化（Silverlight就是如此）要快得多。<br>下图是这次曲面细分看起来的样子。对于熟悉3D编程的人来说，你们或许已经注意到这是一个三角形条带。注意，在曲面细分中圆形看起来并不完整。WPF然后将这次曲面细分的结果加载到GPU顶点缓存区，并根据在xaml中定义的画笔颜色，使用像素着色器来发起另外一个绘制命令。</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image004_thumb.png?w=481&amp;h=476" alt=""></p><p>还记得我提到这个圆形开起来是不完整的吗？事实上它的确是。WPF然后生成一种Direct3D程序员知道的“线序列”。GPU像理解三角形一样理解直线。WPF将这些线条填充到一个顶点缓存区中…然后你可以猜到！又发起另外一个绘制调用。这是这些线条集合看起来的样子：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image005_thumb.png?w=474&amp;h=472" alt=""></p><p>所以，WPF已经完成了对圆形的绘制，对吧？并没有！你忘了它还有一条外描边！外描边同样是一个线条集合。这个集合会被发送到GPU的顶点缓存区并且另外一条绘制命令也会被调用。这是描边看起来的样子：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image006_thumb.png?w=476&amp;h=476" alt=""></p><p>到目前为止我们完成了一个圆形的绘制，我们的帧看起来是这样的：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image007_thumb.png?w=511&amp;h=310" alt=""></p><p>这个流程在这个场景下要为每个圆形进行一次。在这里是两个。</p><h2 id="我就不明白了，为什么这样对性能有害？"><a href="#我就不明白了，为什么这样对性能有害？" class="headerlink" title="我就不明白了，为什么这样对性能有害？"></a><strong>我就不明白了，为什么这样对性能有害？</strong></h2><p>你应该注意到的第一件事情是为了绘制一个圆形它需要调用3次绘制。在这3次绘制调用中，相同的顶点缓存区被使用了两次。为了解释为什么只是低效率的，我需要稍微解释一些GPU是怎样工作的。首先，今日的GPU以非常快的速度处理数据并且异步地和CPU一起运行。并且，在确定的操作中存在耗时的用户态到核心态的切换。在这个例子里，在填充顶点缓存区时一定要锁定它。如果当前GPU正在使用缓存区，这样会导致GPU与CPU同步，引起性能瓶颈。顶点缓存区是通过 D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC创建的，但是当它被锁定时（事实上经常发生），D3DLOCK_DISCARD 并没有被使用。如果缓存区正在被GPU使用可能会导致GPU“失速”（CPU与GPU同步）。在存在很多绘制调用的例子中，我们可能有大量的内核过渡和驱动负载。高性能的目标是发送尽量多的工作给GPU，否则你的CPU会忙的要死而GPU却非常空闲。同样，不要忘了在这个例子中我只谈到一帧。典型的WPF UI会尝试在每秒里处理60帧！如果你曾怀疑过那些渲染线程的高CPU占用是从哪里来的，你会发现许多（大部分）是来自GPU驱动。</p><h2 id="那Cached-Composition呢？这真的能提升性能"><a href="#那Cached-Composition呢？这真的能提升性能" class="headerlink" title="那Cached Composition呢？这真的能提升性能"></a><strong>那Cached Composition呢？这真的能提升性能</strong></h2><p>毫无疑问的确如此。Cached Composition，也就是BitmapCache，通过缓存GPU贴图的图像来工作。这意味着你的CPU不用重新对图像进行曲面细分，GPU也不用重新栅格化。在一次渲染当中，WPF通过使用显存中的贴图来进行渲染以提高性能。下图是一个圆形的BitmapCache:</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image008_thumb.png?w=244&amp;h=247" alt=""></p><p>WPF在这方面也是存在缺陷的。对于每一个它遇到的BitmapCache，它发起一次绘制调用。公平来讲，有时候在某些情况下为了渲染图像你必须发起一次渲染调用。这是自然而然的。但是我们举一个例子：在一个Canvas里面填充300个BitmapCache圆形。一个高级系统会知道它有300个依层次排列的圆形。然后向DX9一次处理16个采样输入那样，尽量多地批量处理这些圆形。在这个例子中，可以将300次绘制调用降低到19次并节省可观的CPU负载。在60FPS的情况下，我们可以将每秒18000次的绘制调用较低到1125次。在Direct3D 10中，一次能够处理的采样输出（sampler input）还要高得多。</p><h2 id="好的，我读到这里了，告诉我-WPF-是怎样处理像素着色器的！"><a href="#好的，我读到这里了，告诉我-WPF-是怎样处理像素着色器的！" class="headerlink" title="好的，我读到这里了，告诉我 WPF 是怎样处理像素着色器的！"></a><strong>好的，我读到这里了，告诉我 WPF 是怎样处理像素着色器的！</strong></h2><p>WPF 有一个可扩展的像素着色器API，一起的还有一些内置的效果。这允许程序员为他们的UI添加一些非常特别的效果。在Direct3D中，当你要为一个贴图添加着色器，典型的做法是使用intermediate rendertarget…毕竟，你不能对你正在写入数据的贴图进行采样。WPF 也是这样的，但不幸的是，它每次都会为每一帧生成一个新的贴图并且在完成后将贴图销毁。在每帧中，生成和销毁GPU资源是其中一件你能做的最慢的事情之一。如果这些中间的资源能够被重复利用，在使用着色器时将可能有一个可观的性能提升。如果你曾因为在使用这些硬件加速驱动的着色器而导致明显的CPU占用问题而搞到困扰时，这就是原因。</p><h2 id="或许这才是矢量图形在GPU渲染的方式"><a href="#或许这才是矢量图形在GPU渲染的方式" class="headerlink" title="或许这才是矢量图形在GPU渲染的方式!"></a><strong>或许这才是矢量图形在GPU渲染的方式!</strong></h2><p>微软花费了大量的努力来解决这些问题，不幸的是这并不是针对WPF。答案是Direct2D。考虑这组在Direct2D中渲染的9个描边的圆形：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image009_thumb.png?w=292&amp;h=293" alt=""></p><p>还记得WPF渲染一个描边的圆形需要多少次绘制调用吗？以及多少顶点缓存区被锁定？Direct2D只需要1次绘制调用。这是曲面细分看起来的样子：</p><p><img src="https://jeremiahmorrill.files.wordpress.com/2011/02/clip_image010_thumb.png?w=402&amp;h=659" alt=""></p><p>Direct2D尝试在一次中尽量绘制多地内容，最大化GPU使用并且最小化不必要的CPU负载。在这篇文章<a href="https://msdn.microsoft.com/en-us/magazine/dd861344.aspx" target="_blank" rel="noopener">“Insights: Direct2D Rendering”</a>底部，Mark Lawrence，使用大量细节解释了Direct2D的工作方式。你深入了解会发现，即使Direct2D运行的非常快，在很多方面它都可以在第二版本中进行改进。相信Direct2D的第二版会支持DX11的硬件曲面细分技术想必也不是那么不合逻辑。</p><p>查阅Direct2D的API，说其中很多代码就是从WPF里面拿的，也不是什么疯狂的想法。如果你看这个老<a href="http://channel9.msdn.com/Blogs/Charles/Michael-Wallent-Advent-and-Evolution-of-WPF" target="_blank" rel="noopener">视频</a>,Micheal Wallent确实说过从这项技术上去创造一个原生的GDI技术作为替代。它有相似的几何图形API和命名。内部也坐着很多相同的事情，但是却更加优化和现代。</p><h2 id="那Silverlight呢？"><a href="#那Silverlight呢？" class="headerlink" title="那Silverlight呢？"></a><strong>那Silverlight呢？</strong></h2><p>我会深入讲Silverlight，但可能有点多余。Silverlight的渲染性能是低效的，但是因为另外的方式。它在CPU上进行栅格化（即使是着色器，如果我没记错的话，是使用汇编语言写的），但是CPU起码比GPU慢10-30倍。这导致你只有相当少的能力渲染UI，甚至更少的能力给到程序逻辑。它的硬件加速是非常基础的，并且几乎和WPF的Cache Composition一样，对于每个BitmapCached图像都要调用一次绘制调用。</p><h2 id="我们能怎样做？"><a href="#我们能怎样做？" class="headerlink" title="我们能怎样做？"></a><strong>我们能怎样做？</strong></h2><p>这是一个我的客户在使用WPF或者Silverlight遇到性能问题时提到的共同问题。不幸的是，我也没有一个答复给到他们。有些可以为了他们特定的需求使用自己的框架。其他的，我尽量倾听，但是他们必须忍受它，毕竟并没有其他丰富的选择来替代WPF和Silverlight。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇2011年的文章，原地址在 &lt;a href=&quot;https://jeremiahmorrill.wordpress.com/2011/02/14/a-critical-deep-dive-into-the-wpf-rendering-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Critical Deep Dive into the WPF Rendering System&lt;/a&gt;，个人认为到现在都可以给WPF程序开发人员作为一个参考，里面详细讲述了 WPF 这个号称从底层支持硬件加速的 UI 框架为什么有时候看起来并不是那么回事的原因。以下是正文。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;刚开始我并不认为我会发表这篇文章。在被一些我高度重视的人说服后，我决定要发表这篇文章。那些深入投入微软UX平台的程序员应该更加深入了解这个平台内部是怎么工作的，当他们撞到一睹石墙的时候，他们可以清晰了解到问题所在并且更加准确地沟通他们希望平台做出怎样的改变。&lt;/p&gt;
&lt;h2 id=&quot;我相信-WPF-和-Silverlight-是精心打造的技术，但是…&quot;&gt;&lt;a href=&quot;#我相信-WPF-和-Silverlight-是精心打造的技术，但是…&quot; class=&quot;headerlink&quot; title=&quot;我相信 WPF 和 Silverlight 是精心打造的技术，但是…&quot;&gt;&lt;/a&gt;&lt;strong&gt;我相信 WPF 和 Silverlight 是精心打造的技术，但是…&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如果这几个月你有关注我的Twitter，你也许会发现我一直在吐槽WPF（Silverlight也一样）的性能。为什么我会这样做？毕竟这些年我花费了大量的时间为这个平台布道、写库、社区帮助和指导等等。准确来讲，我个人全身投入到这个平台里面，我希望这个平台越来越好。&lt;/p&gt;
&lt;h2 id=&quot;性能，性能，性能&quot;&gt;&lt;a href=&quot;#性能，性能，性能&quot; class=&quot;headerlink&quot; title=&quot;性能，性能，性能&quot;&gt;&lt;/a&gt;&lt;strong&gt;性能，性能，性能&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;当在开发沉浸式的、消费者导向的UX的时候，性能是你第一位的特性。性能是你添加其他特性的前提和基础。有多少次因为UI太卡你需要缩小UI的规模？有多少次因为这个技术做不到所以你需要丢弃“开创性的UX模型”？有多少次你告诉客户他们需要一个2.4GHz的四核CPU才能获得全部的体验？我一直以来都被客户问，为什么在PC上拥有4倍于iPad的性能的情况下，WPF程序却做不到像iPad应用那般流畅？&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="WPF" scheme="https://gandalfliang.github.io/tags/WPF/"/>
    
      <category term="GPU" scheme="https://gandalfliang.github.io/tags/GPU/"/>
    
      <category term="渲染" scheme="https://gandalfliang.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="DirectX" scheme="https://gandalfliang.github.io/tags/DirectX/"/>
    
      <category term="翻译" scheme="https://gandalfliang.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
